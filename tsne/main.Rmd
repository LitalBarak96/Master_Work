---
title: "Tsne"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:


## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
 library(openxlsx)
  dirs <- as.data.frame(read.xlsx("F:/allGroups/dirs.xlsx"))
  num_of_pop<<-nrow(dirs)
  
  
  dir=as.data.frame(lapply(structure(.Data=1:1,.Names=1:1),function(x) numeric(num_of_pop)))
for (i in 1:num_of_pop){
  dir[i,1]<-dirs$groupNameDir[i]
}
#xlsxFile <<- choose.files(default = "", caption = "Select expData file")

groupsNames <<- as.character(basename(dirs$groupNameDir))

#chnage the dir values so it would be readable
dir$X1<-gsub("\\\\", "/", dir$X1)
for(i in 1:num_of_pop){
  dir[i,1]<-str_trim(dir[i,1], side = c("right"))
}




library("dplyr")
library("stringr")

Female<-data.frame()
Male<-data.frame()



#feature_names<-all_features %>%
# select(-ends_with('~'))
index<-0

for(i in 1:num_of_pop){
    index<-index+1
    setwd(dir[i,1])
    all_features<-read.csv("combined_per_fly.csv")
    #getting the colom names - getting the feature name e.g aggregation 
    feature_names<-all_features %>%
      select(starts_with('file'))
    
    #taking the first row of it and removing the col names
    names_data_frame<-as.data.frame(t(feature_names[1,]))
    rownames(names_data_frame)<-(NULL)
    colnames(names_data_frame)<-c("feature_name")
    #replace the feature names so they won't end with .mat ending
    names_data_frame$feature_name<- str_replace(names_data_frame$feature_name ,".mat", "")
    #converting them to list
    names_in_list<-as.list(names_data_frame$feature_name)
    all_features_names<-all_features$dir
    all_features_names<-as.data.frame(all_features_names)
    colnames(all_features_names)<-c("id")
    #taking the movie name and calling it id
    
    #taking only the values
    all_features_valus<-all_features %>%
      select(starts_with('valu'))
    #putting the name of the feature as colom name to the values
    colnames(all_features_valus)<-c(names_in_list)
    
    
    #test<-all_features_valus[,!grepl("*~",names(all_features_valus))]
    #connecting the names of the movies to the value and feature name
    
    #all_features_names<-cbind(all_features_names,all_features_valus[,!grepl("*~",names(all_features_valus))])
    all_features_names<-cbind(all_features_names,all_features_valus)
    all_features_names$id<-c(basename(dir[i,1]))
    if(index==1){
      all_feature_final<-all_features_names
    }else{
      all_feature_final<-rbind(all_feature_final,all_features_names)
      
    }
    #putting factor on the label
    all_feature_final$id<-as.factor(all_feature_final$id)
  }

#this part was problematic for the random forest
colnames(all_feature_final) <- make.names(colnames(all_feature_final))


#check balance
all_feature_final %>% 
  count(id) %>% 
  mutate(prop = n/sum(n))
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.



```{r}
  library(openxlsx)
  dirs <- as.data.frame(read.xlsx("F:/allGroups/dirs.xlsx"))
  num_of_pop<<-nrow(dirs)
  
  
  dir=as.data.frame(lapply(structure(.Data=1:1,.Names=1:1),function(x) numeric(num_of_pop)))
for (i in 1:num_of_pop){
  dir[i,1]<-dirs$groupNameDir[i]
}
#xlsxFile <<- choose.files(default = "", caption = "Select expData file")

groupsNames <<- as.character(basename(dirs$groupNameDir))

#chnage the dir values so it would be readable
dir$X1<-gsub("\\\\", "/", dir$X1)
for(i in 1:num_of_pop){
  dir[i,1]<-str_trim(dir[i,1], side = c("right"))
}




library("dplyr")
library("stringr")

Female<-data.frame()
Male<-data.frame()



#feature_names<-all_features %>%
# select(-ends_with('~'))
Female_index<-0
Male_index<-0

for(i in 1:num_of_pop){
  if(str_detect(basename(dir[i,1]), "Females")){
    Female_index<-Female_index+1
    setwd(dir[i,1])
    all_features<-read.csv("combined_per_fly.csv")
    #getting the colom names - getting the feature name e.g aggregation 
    feature_names<-all_features %>%
      select(starts_with('file'))
    
    #taking the first row of it and removing the col names
    names_data_frame<-as.data.frame(t(feature_names[1,]))
    rownames(names_data_frame)<-(NULL)
    colnames(names_data_frame)<-c("feature_name")
    #replace the feature names so they won't end with .mat ending
    names_data_frame$feature_name<- str_replace(names_data_frame$feature_name ,".mat", "")
    #converting them to list
    names_in_list<-as.list(names_data_frame$feature_name)
    all_features_names<-all_features$dir
    all_features_names<-as.data.frame(all_features_names)
    colnames(all_features_names)<-c("id")
    #taking the movie name and calling it id
    
    #taking only the values
    all_features_valus<-all_features %>%
      select(starts_with('valu'))
    #putting the name of the feature as colom name to the values
    colnames(all_features_valus)<-c(names_in_list)
    
    
    #test<-all_features_valus[,!grepl("*~",names(all_features_valus))]
    #connecting the names of the movies to the value and feature name
    
    #all_features_names<-cbind(all_features_names,all_features_valus[,!grepl("*~",names(all_features_valus))])
    all_features_names<-cbind(all_features_names,all_features_valus)
    all_features_names$id<-c("Female")
    if(Female_index==1){
      Female<-all_features_names
    }else{
      Female<-rbind(Female,all_features_names)
      
    }
    #putting factor on the label
    Female$id<-as.factor(Female$id)
  }
  
  
  
  if(str_detect(basename(dir[i,1]), "Males")){
    Male_index<-Male_index+1
    setwd(dir[i,1])
    all_features<-read.csv("combined_per_fly.csv")
    #getting the colom names - getting the feature name e.g aggregation 
    feature_names<-all_features %>%
      select(starts_with('file'))
    #taking the first row of it and removing the col names
    names_data_frame<-as.data.frame(t(feature_names[1,]))
    rownames(names_data_frame)<-(NULL)
    colnames(names_data_frame)<-c("feature_name")
    #replace the feature names so they won't end with .mat ending
    names_data_frame$feature_name<- str_replace(names_data_frame$feature_name ,".mat", "")
    #converting them to list
    names_in_list<-as.list(names_data_frame$feature_name)
    all_features_names<-all_features$dir
    all_features_names<-as.data.frame(all_features_names)
    colnames(all_features_names)<-c("id")
    #taking the movie name and calling it id
    
    #taking only the values
    all_features_valus<-all_features %>%
      select(starts_with('valu'))
    #putting the name of the feature as colom name to the values
    colnames(all_features_valus)<-c(names_in_list)
    
    #connecting the names of the movies to the value and feature name
    all_features_names<-cbind(all_features_names,all_features_valus)
    all_features_names$id<-c("Male")
    
    if(Male_index==1){
      Male<-all_features_names
    }else{
      Male<-rbind(Male,all_features_names)
      
    }
    #putting factor on the label
    Male$id<-as.factor(Male$id)
  }
  
  
}
all_feature_final<-rbind(Female,Male)

#this part was problematic for the random forest
colnames(all_feature_final) <- make.names(colnames(all_feature_final))


#check balance
all_feature_final %>% 
  count(id) %>% 
  mutate(prop = n/sum(n))
```



```{r}
library(readr)
library(Rtsne)
actuall_data<-all_feature_final[,-1]
#scale them to 1
dat <- data.frame(lapply(actuall_data, function(x) scale(x, center = FALSE, scale = max(x, na.rm = TRUE)/1)))

tag<-all_feature_final[,1]

library(Rtsne)





## Run the t-SNE algorithm and store the results into an object called tsne_results
tsne_results <- Rtsne(actuall_data, perplexity=30, check_duplicates = FALSE)
plot(tsne_results$Y, col = "black", bg= tag, pch = 21, cex = 1.5)
text(tsne_results$Y, labels=tag, col=colors[tag])
```



```{r}


actuall_data<-all_feature_final[,-1]
#scale them to 1
dat <- data.frame(lapply(actuall_data, function(x) scale(x, center = FALSE, scale = max(x, na.rm = TRUE)/1)))

tag<-all_feature_final[,1]


numTrain <-1190
set.seed(1)
rows <- sample(1:nrow(all_feature_final), numTrain)
train <- all_feature_final[rows,]

set.seed(1) # for reproducibility
tsne <- Rtsne(train[,-1], dims = 3, perplexity=30, verbose=TRUE, max_iter = 500)


colors = rainbow(length(unique(all_feature_final$id)))
names(colors) = unique(all_feature_final$id)

plot(tsne$Y, t='n', main="tSNE", xlab="tSNE dimension 1", ylab="tSNE dimension 2", "cex.main"=2, "cex.lab"=0.5)
text(tsne$Y, labels=all_feature_final$id, col=colors[all_feature_final$id])

```
```{r}
tsne_plot <- function(perpl=50,iterations=100,learning=200){
  set.seed(1) # for reproducibility
  tsne <- Rtsne(train[,-1], dims = 2, perplexity=perpl, verbose=TRUE, max_iter=iterations, eta=learning)
  plot(tsne$Y, t='n', main = print(paste0("perplexity = ",perpl, ", max_iter = ",iterations, ", learning rate = ",learning)), xlab="tSNE dimension 1", ylab="tSNE dimension 2", "cex.main"=1, "cex.lab"=1.5)
  text(tsne$Y, labels=train$id, col=colors[train$id],cex=0.5)
}

perplexity_values <- c(2,5,20,25,40,50,60,70,80,90,100)
sapply(perplexity_values,function(i){tsne_plot(perpl=i)})
```

```{r}

learning_values <- c(20,200,2000)
sapply(learning_values,function(i){tsne_plot(learning=i)})
```
```{r}

par(mfrow=c(3,3))
optPerp <- round(sqrt(104),0)
for(i in c(5, 10, 20, 50, 100, 200, 300, 500,5000))
{
	tsne <- Rtsne(train[,-1],
		      perplexity=20, max_iter=i)
	plot(tsne$Y, col="blue", xlab="tSNE1", ylab="tSNE2", cex=0.5)
	mtext(paste0("max_iter = ", i))
}
```

